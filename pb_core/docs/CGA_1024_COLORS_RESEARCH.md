# CGA 1024 Colors: Mathematical Research and Cleanroom Implementation Guide

## Executive Summary

This document provides a comprehensive analysis of the techniques used to generate 1024 colors
on IBM CGA hardware through NTSC composite video artifact manipulation. The research is derived
from primary sources and is intended for cleanroom implementation in the pb_core rendering system.

---

## Table of Contents

1. [Historical Context](#1-historical-context)
2. [NTSC Color Fundamentals](#2-ntsc-color-fundamentals)
3. [CGA Hardware Architecture](#3-cga-hardware-architecture)
4. [Artifact Color Mathematics](#4-artifact-color-mathematics)
5. [The 1024-Color Technique](#5-the-1024-color-technique)
6. [Mathematical Formulas](#6-mathematical-formulas)
7. [Implementation Algorithms](#7-implementation-algorithms)
8. [Display Mode Targets](#8-display-mode-targets)
9. [Primary Sources](#9-primary-sources)
10. [Cleanroom Implementation Plan](#10-cleanroom-implementation-plan)

---

## 1. Historical Context

### Origin: 8088 MPH Demo (April 2015)

The 1024-color CGA technique was publicly demonstrated at Revision 2015 demoparty in
Saarbrücken, Germany. The demo "8088 MPH" by Hornet, CRTC, and Desire won first place
in the Oldskool Demo competition.

**Key Contributors:**
- **reenigne (Andrew Jenner)**: Mathematical model and NTSC simulation
- **VileR**: Initial 512-color discovery and illustrated documentation
- **Trixter (Jim Leonard)**: Demo coordination and optimization
- **Scali**: Technical implementation

### Evolution of Artifact Colors

| Year | Technique | Colors | Resolution | Platform |
|------|-----------|--------|------------|----------|
| 1977 | Apple II HGR | 6 | 140x192 | Apple II |
| 1981 | CGA Mode 6 | 16 | 160x200 | IBM CGA |
| 2015 | 8088 MPH | 1024 | 80x100 | IBM CGA |

---

## 2. NTSC Color Fundamentals

### 2.1 Color Subcarrier

NTSC encodes color using Quadrature Amplitude Modulation (QAM) of a subcarrier signal.

**Key Frequencies:**
```
Color subcarrier:  3.579545 MHz (exactly 315/88 MHz)
Pixel clock:       14.318180 MHz (4x subcarrier)
Color cycles/line: 160 (per active CGA scanline)
```

### 2.2 YIQ Color Space

NTSC uses YIQ color encoding:

**RGB to YIQ Conversion Matrix:**
```
[Y]   [ 0.299   0.587   0.114] [R]
[I] = [ 0.596  -0.274  -0.322] [G]
[Q]   [ 0.211  -0.523   0.312] [B]
```

**YIQ to RGB Inverse Matrix:**
```
[R]   [1.000   0.956   0.621] [Y]
[G] = [1.000  -0.272  -0.647] [I]
[B]   [1.000  -1.106   1.703] [Q]
```

**Component Ranges:**
- Y: [0, 1] - Luminance
- I: [-0.5957, 0.5957] - In-phase (orange-blue)
- Q: [-0.5226, 0.5226] - Quadrature (purple-green)

### 2.3 Chroma Signal Encoding

The chroma signal is encoded as:
```
C(t) = I * sin(2π * f_sc * t) + Q * cos(2π * f_sc * t)
```

Where:
- `f_sc` = 3.579545 MHz (color subcarrier frequency)
- Phase angle determines hue: `θ = atan2(Q, I)`
- Amplitude determines saturation: `A = sqrt(I² + Q²)`

### 2.4 Color Burst Reference

- 9 cycles of subcarrier at 180° phase
- Located on horizontal back porch
- Provides phase reference for chroma demodulation

---

## 3. CGA Hardware Architecture

### 3.1 RGBI Color Model

CGA uses 4-bit RGBI (Red, Green, Blue, Intensity):

| Bit | Signal | Weight |
|-----|--------|--------|
| 0   | Blue   | Base   |
| 1   | Green  | Base   |
| 2   | Red    | Base   |
| 3   | Intensity | +1/3 |

### 3.2 Composite Output Circuit

**Old CGA (1804472, 1501486):**
```
COMPOSITE = 0.72 * CHROMA + 0.28 * I
```

**New CGA (1504910, 1501981):**
```
COMPOSITE = 0.29 * CHROMA + 0.10 * R + 0.22 * G + 0.07 * B + 0.32 * I
```

Where CHROMA is generated by phase-shifting flip-flops creating 6 distinct phases
for colors 1-6, 9-14 (blue, green, cyan, red, magenta, yellow and their bright variants).

### 3.3 Timing Architecture

```
Master oscillator:     14.318180 MHz (from ISA bus)
Pixel clock:           14.318180 MHz
Color subcarrier:      3.579545 MHz (14.318180 / 4)
Pixels per color cycle: 4 (in 640x200 mode)
                        2 (in 320x200 mode)
```

### 3.4 Chroma Phase Delays (Reenigne Model)

Measured nanosecond delays per color:
```c
float chroma_pixel_delays[16] = {
    0.0,    // 0: Black (no chroma)
    35.0,   // 1: Blue
    44.5,   // 2: Green
    39.5,   // 3: Cyan
    35.0,   // 4: Red
    35.0,   // 5: Magenta
    44.5,   // 6: Brown/Yellow
    0.0,    // 7: White (no chroma)
    0.0,    // 8: Gray (no chroma)
    35.0,   // 9: Light Blue
    44.5,   // 10: Light Green
    39.5,   // 11: Light Cyan
    35.0,   // 12: Light Red
    35.0,   // 13: Light Magenta
    44.5,   // 14: Light Yellow
    0.0     // 15: Bright White (no chroma)
};
```

Hue shift per nanosecond: `567.0 / 440` degrees

---

## 4. Artifact Color Mathematics

### 4.1 How Artifact Colors Work

The NTSC decoder interprets high-frequency luminance transitions as color information.
When pixels alternate at rates near the color subcarrier frequency, the decoder
"sees" a chroma signal where none was intended.

**Pixel Pattern to Color Mapping (640x200, 4 pixels per cycle):**

| Pattern (binary) | Phase | Resulting Color |
|------------------|-------|-----------------|
| 0000             | -     | Black           |
| 0001             | 0°    | Blue            |
| 0010             | 90°   | Green           |
| 0011             | 45°   | Cyan            |
| 0100             | 180°  | Red             |
| 0101             | 135°  | Magenta         |
| 0110             | 225°  | Yellow/Brown    |
| 0111             | 180°  | White (low sat) |
| 1000             | 180°  | Dark (low sat)  |
| 1001             | 315°  | Purple          |
| 1010             | 270°  | Olive           |
| 1011             | 225°  | Light Cyan      |
| 1100             | 0°    | Orange          |
| 1101             | 45°   | Pink            |
| 1110             | 90°   | Light Green     |
| 1111             | -     | White           |

### 4.2 Fourier Analysis

Any periodic signal at the color subcarrier frequency produces a perceived color.
The composite signal can be modeled as a Fourier series:

```
f(x) = a + b*sin(x*τ) + c*cos(x*τ) + d*sin(2x*τ)
```

Where:
- `τ = 2π`
- `a` = DC component (luminance)
- `b, c` = fundamental frequency components (chroma)
- `d` = second harmonic (filtered out by NTSC decoder)

### 4.3 Nyquist Sampling

Relevant color information exists below 7.16 MHz (2x subcarrier).
Sampling at the pixel clock (14.318 MHz) fully captures observable colors:

```
f_nyquist = f_pixel / 2 = 7.159 MHz
```

---

## 5. The 1024-Color Technique

### 5.1 Text Mode Exploitation

The technique uses 80x25 text mode with the color burst enabled, displaying
only the top 1-2 scanlines of each character cell.

**Key Characters (CP437):**
| Char | Code | Bit Pattern | Phase Offset |
|------|------|-------------|--------------|
| U    | 0x55 | 11001100    | 0°           |
| ‼    | 0x13 | 01100110    | 90°          |
| ░    | 0xB0 | 00100010    | Special      |
| ▒    | 0xB1 | 01010101    | Special      |

### 5.2 Color Count Derivation

**Base Colors:**
- 16 foreground colors × 16 background colors = 256 combinations
- Characters U (0x55) and ‼ (0x13) provide 90° phase difference
- 256 × 2 = 512 colors

**CRTC Doubling (1024 colors):**
- Characters ░ (0xB0) and ▒ (0xB1) double the first scanline
- Requires CRTC start address manipulation every 2 scanlines
- 512 × 2 = 1024 colors

### 5.3 Effective Resolution

```
Horizontal: 80 characters × 2 color clocks = 160 color cycles
Vertical:   100 lines (with CRTC manipulation)
Effective:  80 × 100 "puffy pixels"
```

### 5.4 Transition Parameterization

A color transition is described by 1024 parameters:
```
16 left colors × 16 right colors × 4 phase positions = 1024
```

Each parameter describes the output waveform shape during the transition
between two adjacent colors.

---

## 6. Mathematical Formulas

### 6.1 NTSC Encoding (Composite Signal Generation)

```c
// Generate composite signal for a given pixel pattern
float generate_composite(int rgbi, float phase, float time) {
    // Extract RGBI components
    int r = (rgbi >> 2) & 1;
    int g = (rgbi >> 1) & 1;
    int b = (rgbi >> 0) & 1;
    int i = (rgbi >> 3) & 1;

    // Calculate luminance (Y)
    float Y = 0.299 * r + 0.587 * g + 0.114 * b;
    Y = Y * 0.67 + i * 0.33;  // Apply intensity

    // Generate chroma signal
    float chroma_phase = get_chroma_phase(rgbi);
    float C = get_chroma_amplitude(rgbi);

    // Composite = Y + C * sin(2π * f_sc * t + phase)
    float omega = 2.0 * M_PI * 3.579545e6;
    return Y + C * sin(omega * time + chroma_phase + phase);
}
```

### 6.2 NTSC Decoding (RGB Recovery)

```c
// Decode composite signal to RGB
void decode_ntsc(float* composite, int length, float* rgb_out) {
    float omega = 2.0 * M_PI * 3.579545e6;

    for (int x = 0; x < length; x++) {
        // Low-pass filter for Y (bandwidth: 4.2 MHz)
        float Y = lowpass_filter(composite, x, 4.2e6);

        // Band-pass filter for chroma (centered at 3.58 MHz)
        float chroma = bandpass_filter(composite, x, 3.58e6, 1.0e6);

        // Demodulate I and Q
        float t = x / 14.318e6;
        float I = chroma * sin(omega * t) * 2.0;  // Multiply by reference
        float Q = chroma * cos(omega * t) * 2.0;

        // Low-pass I and Q (1.0 MHz bandwidth)
        I = lowpass_filter_single(I, 1.0e6);
        Q = lowpass_filter_single(Q, 1.0e6);

        // YIQ to RGB
        rgb_out[x*3 + 0] = Y + 0.956 * I + 0.621 * Q;  // R
        rgb_out[x*3 + 1] = Y - 0.272 * I - 0.647 * Q;  // G
        rgb_out[x*3 + 2] = Y - 1.106 * I + 1.703 * Q;  // B
    }
}
```

### 6.3 Artifact Color Generation

```c
// Calculate artifact color for a 4-pixel pattern
pb_rgb8 artifact_color(uint8_t pattern, int phase_offset) {
    // Pattern is 4 bits representing 4 pixels
    // phase_offset is 0, 1, 2, or 3 (90° increments)

    float Y = 0, I = 0, Q = 0;

    for (int i = 0; i < 4; i++) {
        int pixel = (pattern >> (3 - i)) & 1;
        float phase = (i + phase_offset) * M_PI / 2.0;

        Y += pixel * 0.25;
        I += pixel * sin(phase) * 0.25;
        Q += pixel * cos(phase) * 0.25;
    }

    // Apply NTSC decoding bandwidth limits
    I *= 0.7;  // I bandwidth reduction
    Q *= 0.5;  // Q bandwidth reduction

    // YIQ to RGB
    float R = Y + 0.956 * I + 0.621 * Q;
    float G = Y - 0.272 * I - 0.647 * Q;
    float B = Y - 1.106 * I + 1.703 * Q;

    // Clamp and convert to 8-bit
    pb_rgb8 result;
    result.r = (uint8_t)(fmax(0, fmin(1, R)) * 255);
    result.g = (uint8_t)(fmax(0, fmin(1, G)) * 255);
    result.b = (uint8_t)(fmax(0, fmin(1, B)) * 255);

    return result;
}
```

### 6.4 Reenigne Chroma Multiplexer Model

```c
// Reenigne's chroma multiplexer algorithm
// Models the analog behavior of CGA's TTL flip-flops

#define TAU 6.28318531
#define NS_PER_DEGREE (567.0 / 440.0)

typedef struct {
    float y;      // Luminance
    float i;      // In-phase chroma
    float q;      // Quadrature chroma
} yiq_t;

// Phase angles for each RGBI color (in degrees)
static const float color_phases[16] = {
    0,      // 0: Black (no phase)
    240,    // 1: Blue
    120,    // 2: Green
    180,    // 3: Cyan
    0,      // 4: Red
    300,    // 5: Magenta
    60,     // 6: Brown
    0,      // 7: White (no phase)
    0,      // 8: Gray (no phase)
    240,    // 9: Light Blue
    120,    // 10: Light Green
    180,    // 11: Light Cyan
    0,      // 12: Light Red
    300,    // 13: Light Magenta
    60,     // 14: Yellow
    0       // 15: Bright White (no phase)
};

// Saturation levels per RGBI color
static const float color_saturation[16] = {
    0.0,    // 0: Black
    0.7,    // 1: Blue
    0.7,    // 2: Green
    0.7,    // 3: Cyan
    0.7,    // 4: Red
    0.7,    // 5: Magenta
    0.7,    // 6: Brown
    0.0,    // 7: White
    0.0,    // 8: Gray
    0.6,    // 9: Light Blue
    0.6,    // 10: Light Green
    0.6,    // 11: Light Cyan
    0.6,    // 12: Light Red
    0.6,    // 13: Light Magenta
    0.6,    // 14: Yellow
    0.0     // 15: Bright White
};

yiq_t cga_to_yiq(int rgbi, bool new_cga) {
    yiq_t result;

    int r = (rgbi >> 2) & 1;
    int g = (rgbi >> 1) & 1;
    int b = rgbi & 1;
    int i = (rgbi >> 3) & 1;

    // Calculate luminance
    if (new_cga) {
        result.y = 0.10 * r + 0.22 * g + 0.07 * b + 0.32 * i;
        result.y += 0.29 * color_saturation[rgbi];
    } else {
        result.y = 0.28 * i + 0.72 * color_saturation[rgbi];
    }

    // Add base luminance for lit pixels
    float base_luma = (r + g + b) / 3.0 * 0.67;
    result.y = base_luma + i * 0.33;

    // Calculate chroma
    float phase_rad = color_phases[rgbi] * TAU / 360.0;
    float sat = color_saturation[rgbi];

    result.i = sat * cos(phase_rad);
    result.q = sat * sin(phase_rad);

    return result;
}
```

### 6.5 1024-Color Palette Generation

```c
// Generate complete 1024-color palette
void generate_1024_palette(pb_rgb8* palette) {
    int idx = 0;

    // 512 colors from character 'U' (0x55)
    for (int fg = 0; fg < 16; fg++) {
        for (int bg = 0; bg < 16; bg++) {
            palette[idx++] = calculate_text_artifact_color(
                0x55, fg, bg, 0  // phase 0
            );
        }
    }

    // 512 colors from character '‼' (0x13)
    for (int fg = 0; fg < 16; fg++) {
        for (int bg = 0; bg < 16; bg++) {
            palette[idx++] = calculate_text_artifact_color(
                0x13, fg, bg, 1  // phase 90°
            );
        }
    }

    // Additional 512 from ░ and ▒ with CRTC tricks
    // (doubles first scanline - requires hardware timing)
}

pb_rgb8 calculate_text_artifact_color(
    uint8_t character,
    int fg_color,
    int bg_color,
    int phase_variant
) {
    // Get character bitmap (first scanline)
    uint8_t bitmap = get_char_scanline(character, 0);

    float y_accum = 0, i_accum = 0, q_accum = 0;
    int samples = 0;

    // Process 8 pixels of character width
    for (int px = 0; px < 8; px++) {
        int color = (bitmap & (0x80 >> px)) ? fg_color : bg_color;

        yiq_t yiq = cga_to_yiq(color, false);

        // Apply phase based on pixel position
        float phase = (px + phase_variant * 2) * M_PI / 4.0;

        y_accum += yiq.y;
        i_accum += yiq.i * cos(phase) - yiq.q * sin(phase);
        q_accum += yiq.i * sin(phase) + yiq.q * cos(phase);
        samples++;
    }

    // Average and convert
    float Y = y_accum / samples;
    float I = i_accum / samples;
    float Q = q_accum / samples;

    return yiq_to_rgb8(Y, I, Q);
}
```

---

## 7. Implementation Algorithms

### 7.1 Hill-Climbing Calibration

Reenigne's approach to finding optimal parameters:

```c
// Naive hill-climbing for parameter optimization
typedef struct {
    float params[1024];  // Transition parameters
    float error;         // Total error vs. measured
} calibration_state;

void calibrate_cga_model(
    pb_rgb8* measured_colors,  // 1024 measured reference colors
    calibration_state* state
) {
    const float step = 0.01;
    const int max_iterations = 10000;

    // Initialize with theoretical values
    initialize_theoretical_params(state->params);
    state->error = calculate_total_error(state->params, measured_colors);

    for (int iter = 0; iter < max_iterations; iter++) {
        for (int i = 0; i < 1024; i++) {
            // Try increasing parameter
            state->params[i] += step;
            float new_error = calculate_total_error(state->params, measured_colors);

            if (new_error < state->error) {
                state->error = new_error;
                continue;
            }

            // Try decreasing parameter
            state->params[i] -= 2 * step;
            new_error = calculate_total_error(state->params, measured_colors);

            if (new_error < state->error) {
                state->error = new_error;
                continue;
            }

            // Restore original
            state->params[i] += step;
        }

        // Check convergence
        if (state->error < 0.01) break;
    }
}
```

### 7.2 Composite Signal Simulation

```c
// Full composite signal simulation pipeline
typedef struct {
    float hue_offset;       // User-adjustable hue
    float saturation;       // User-adjustable saturation
    float brightness;       // User-adjustable brightness
    float contrast;         // User-adjustable contrast
    bool new_cga;           // Old vs. new CGA model
} composite_config;

void simulate_composite_output(
    const uint8_t* rgbi_buffer,  // Input: RGBI pixel data
    int width,
    float* composite_out,         // Output: composite signal samples
    const composite_config* cfg
) {
    float omega = 2.0 * M_PI * 3.579545e6;
    float pixel_period = 1.0 / 14.318e6;

    for (int x = 0; x < width; x++) {
        uint8_t rgbi = rgbi_buffer[x];
        float t = x * pixel_period;

        // Get color components
        yiq_t yiq = cga_to_yiq(rgbi, cfg->new_cga);

        // Apply user adjustments
        yiq.y = (yiq.y - 0.5) * cfg->contrast + 0.5 + cfg->brightness;

        float chroma_amp = sqrt(yiq.i * yiq.i + yiq.q * yiq.q);
        float chroma_phase = atan2(yiq.q, yiq.i);

        chroma_amp *= cfg->saturation;
        chroma_phase += cfg->hue_offset * M_PI / 180.0;

        yiq.i = chroma_amp * cos(chroma_phase);
        yiq.q = chroma_amp * sin(chroma_phase);

        // Generate composite signal
        composite_out[x] = yiq.y +
            yiq.i * sin(omega * t) +
            yiq.q * cos(omega * t);
    }
}
```

### 7.3 NTSC Decoder Simulation

```c
// Simulate NTSC decoder to recover RGB from composite
void decode_composite_to_rgb(
    const float* composite,
    int width,
    pb_rgb8* rgb_out,
    const composite_config* cfg
) {
    // FIR filter coefficients for low-pass Y (4.2 MHz cutoff)
    static const float y_filter[9] = {
        0.02, 0.06, 0.12, 0.18, 0.24, 0.18, 0.12, 0.06, 0.02
    };

    // FIR filter for chroma band-pass
    static const float c_filter[5] = {
        -0.25, 0.5, 1.0, 0.5, -0.25
    };

    float omega = 2.0 * M_PI * 3.579545e6;
    float pixel_period = 1.0 / 14.318e6;

    for (int x = 4; x < width - 4; x++) {
        // Extract Y with low-pass filter
        float Y = 0;
        for (int k = -4; k <= 4; k++) {
            Y += composite[x + k] * y_filter[k + 4];
        }

        // Extract chroma with band-pass filter
        float chroma = 0;
        for (int k = -2; k <= 2; k++) {
            chroma += composite[x + k] * c_filter[k + 2];
        }

        // Demodulate I and Q using reference carriers
        float t = x * pixel_period;
        float I = chroma * sin(omega * t + cfg->hue_offset * M_PI / 180.0) * 2.0;
        float Q = chroma * cos(omega * t + cfg->hue_offset * M_PI / 180.0) * 2.0;

        // Apply saturation
        I *= cfg->saturation;
        Q *= cfg->saturation;

        // YIQ to RGB conversion
        float R = Y + 0.956 * I + 0.621 * Q;
        float G = Y - 0.272 * I - 0.647 * Q;
        float B = Y - 1.106 * I + 1.703 * Q;

        // Clamp and store
        rgb_out[x].r = (uint8_t)(fmax(0, fmin(1, R)) * 255);
        rgb_out[x].g = (uint8_t)(fmax(0, fmin(1, G)) * 255);
        rgb_out[x].b = (uint8_t)(fmax(0, fmin(1, B)) * 255);
    }
}
```

---

## 8. Display Mode Targets

### 8.1 Supported Display Types

The pb_cga module will support rendering to multiple display types:

| Display Type | Resolution | Color Depth | Notes |
|--------------|------------|-------------|-------|
| CGA Authentic | 320x200 | 4-1024 | Real NTSC composite |
| EGA/VGA Compat | 320x200 | 16-256 | Palette emulation |
| Modern LCD | Any | 24-bit | SDL2/OpenGL |
| XRender | Any | 24-bit | X11 direct |
| TI-84/83 | 96x64/128x64 | 1-bit | Monochrome |
| TI-89/Nspire | 160x100/320x240 | 4-16 gray | Grayscale |
| Casio fx-CG | 384x216 | 65536 | Full color |
| E-Ink | Various | 2-16 gray | Dithered |
| OLED | Various | 24-bit | Full color |
| CRT Shader | Any | 24-bit | Scanline effects |

### 8.2 Dithering Modes

For limited-color displays, implement ordered dithering:

```c
// Bayer 4x4 dithering matrix
static const int bayer4x4[4][4] = {
    {  0,  8,  2, 10 },
    { 12,  4, 14,  6 },
    {  3, 11,  1,  9 },
    { 15,  7, 13,  5 }
};

// Apply dithering for 1-bit displays
int dither_to_1bit(pb_rgb8 color, int x, int y) {
    // Calculate grayscale value
    int gray = (color.r * 299 + color.g * 587 + color.b * 114) / 1000;

    // Apply Bayer threshold
    int threshold = bayer4x4[y & 3][x & 3] * 16;

    return gray > threshold ? 1 : 0;
}
```

### 8.3 Palette Reduction

For displays with limited palettes:

```c
// Find nearest color in limited palette using Delta E
int find_nearest_color(pb_rgb8 target, const pb_rgb8* palette, int palette_size) {
    float min_distance = FLT_MAX;
    int nearest = 0;

    pb_oklab target_lab = pb_srgb_to_oklab(pb_rgb8_to_rgb(target));

    for (int i = 0; i < palette_size; i++) {
        pb_oklab pal_lab = pb_srgb_to_oklab(pb_rgb8_to_rgb(palette[i]));
        float dist = pb_oklab_delta_e(target_lab, pal_lab);

        if (dist < min_distance) {
            min_distance = dist;
            nearest = i;
        }
    }

    return nearest;
}
```

---

## 9. Primary Sources

### 9.1 Core Technical Documents

1. **"1K colours on CGA: How it's done"** - reenigne (Andrew Jenner)
   - https://www.reenigne.org/blog/1k-colours-on-cga-how-its-done/
   - Primary mathematical model and parameter derivation

2. **"CGA in 1024 Colors - a New Mode: the Illustrated Guide"** - VileR
   - https://int10h.org/blog/2015/04/cga-in-1024-colors-new-mode-illustrated/
   - Comprehensive illustrated technical guide

3. **"8088 MPH Final: Old vs. New CGA"** - VileR
   - https://int10h.org/blog/2015/08/8088-mph-final-old-vs-new-cga-gory-details/
   - Hardware revision differences and formulas

4. **"Comparison of CGA card versions"** - reenigne
   - https://www.reenigne.org/blog/comparison-of-cga-card-versions/
   - Old vs. new CGA composite output formulas

5. **"The IBM 5153's True CGA Palette and Color Output"** - VileR
   - https://int10h.org/blog/2022/06/ibm-5153-color-true-cga-palette/
   - Measured RGBI voltage levels and RGB24 conversions

### 9.2 Implementation References

6. **dbalsom/cga_artifact_color** (Rust)
   - https://github.com/dbalsom/cga_artifact_color
   - Reference implementation for MartyPC emulator

7. **DOSBox-X vga_other.cpp**
   - https://dosbox-x.com/doxygen/html/vga__other_8cpp_source.html
   - Composite simulation code

8. **86Box/PCem CGA emulation**
   - https://github.com/86Box/86Box
   - Production emulator implementation

### 9.3 Hardware Documentation

9. **IBM PC AT Technical Reference** (1984)
   - Original CGA schematic (pages 32-37)
   - Color generation circuit documentation

10. **Colour Graphics Adapter Notes** - John Elliott
    - https://www.seasip.info/VintagePC/cga.html
    - Comprehensive hardware specifications

11. **hkzlab/CGA_Schematics** (KiCad)
    - https://github.com/hkzlab/CGA_Schematics
    - Redrawn CGA schematics

### 9.4 NTSC Color Science

12. **YIQ Color Space** - Wikipedia
    - https://en.wikipedia.org/wiki/YIQ
    - RGB/YIQ conversion matrices

13. **Composite artifact colors** - Wikipedia
    - https://en.wikipedia.org/wiki/Composite_artifact_colors
    - Overview of artifact color techniques

---

## 10. Cleanroom Implementation Plan

### 10.1 Module Structure

```
pb_core/
├── include/pb/
│   ├── pb_cga.h          # Main CGA/artifact color interface
│   ├── pb_ntsc.h         # NTSC encoding/decoding
│   ├── pb_display.h      # Display abstraction layer
│   └── pb_dither.h       # Advanced dithering algorithms
├── src/core/
│   ├── pb_cga.c          # CGA 1024-color implementation
│   ├── pb_ntsc.c         # NTSC simulation
│   └── pb_dither.c       # Dithering routines
├── src/display/
│   ├── pb_display_sdl.c  # SDL2 backend
│   ├── pb_display_xrender.c # XRender backend
│   ├── pb_display_ti.c   # TI calculator backend
│   └── pb_display_eink.c # E-ink backend
└── docs/
    └── CGA_1024_COLORS_RESEARCH.md  # This document
```

### 10.2 API Design

```c
// pb_cga.h - Main interface

// CGA mode enumeration
typedef enum pb_cga_mode {
    PB_CGA_MODE_4COLOR,      // Standard 320x200 4-color
    PB_CGA_MODE_16ARTIFACT,  // 160x200 16 artifact colors
    PB_CGA_MODE_512COLOR,    // 80x100 512 colors (U + ‼)
    PB_CGA_MODE_1024COLOR    // 80x100 1024 colors (full)
} pb_cga_mode;

// CGA hardware variant
typedef enum pb_cga_variant {
    PB_CGA_OLD,    // Early CGA (1983)
    PB_CGA_NEW     // Revised CGA (1984+)
} pb_cga_variant;

// Initialize CGA 1024-color palette
void pb_cga_init_1024_palette(
    pb_palette* pal,
    pb_cga_variant variant,
    float hue_adjust,
    float saturation
);

// Convert RGBI to composite artifact color
pb_rgb8 pb_cga_rgbi_to_artifact(
    uint8_t rgbi,
    int x_position,      // Phase depends on position
    pb_cga_variant variant
);

// Render CGA text mode to artifact colors
void pb_cga_render_text_mode(
    const uint8_t* char_data,
    const uint8_t* attr_data,
    int cols, int rows,
    pb_rgb8* output,
    pb_cga_mode mode,
    pb_cga_variant variant
);
```

### 10.3 Implementation Phases

**Phase 1: Core Mathematics**
- Implement YIQ color space conversions
- Implement NTSC encoding formulas
- Build basic 16-color artifact palette

**Phase 2: 1024-Color Palette**
- Implement character bitmap analysis
- Build transition parameter model
- Generate complete 1024-color lookup table

**Phase 3: Display Backends**
- SDL2/OpenGL renderer
- XRender direct output
- CRT shader effects

**Phase 4: Embedded Targets**
- TI calculator support
- E-ink dithering
- Low-memory optimizations

### 10.4 Testing Strategy

```c
// Validation against known reference values
void test_cga_palette_accuracy(void) {
    pb_palette pal;
    pb_cga_init_1024_palette(&pal, PB_CGA_OLD, 0.0, 1.0);

    // Test known color values from int10h reference
    assert_color_close(pal.colors[0], (pb_rgb8){0, 0, 0});      // Black
    assert_color_close(pal.colors[15], (pb_rgb8){255, 255, 255}); // White

    // Test artifact colors against measured values
    pb_rgb8 artifact = pb_cga_rgbi_to_artifact(0x05, 0, PB_CGA_OLD);
    assert_color_close(artifact, (pb_rgb8){/* expected magenta */});
}
```

---

## Appendix A: Complete RGBI to RGB Mapping (IBM 5153)

Measured values from VileR's analysis:

| Index | RGBI | Canonical RGB | 5153 Measured |
|-------|------|---------------|---------------|
| 0     | 0000 | #000000       | #000000       |
| 1     | 0001 | #0000AA       | #0000C4       |
| 2     | 0010 | #00AA00       | #00C400       |
| 3     | 0011 | #00AAAA       | #00C4C4       |
| 4     | 0100 | #AA0000       | #C40000       |
| 5     | 0101 | #AA00AA       | #C400C4       |
| 6     | 0110 | #AA5500       | #C47E00       |
| 7     | 0111 | #AAAAAA       | #C4C4C4       |
| 8     | 1000 | #555555       | #4E4E4E       |
| 9     | 1001 | #5555FF       | #4E4EFF       |
| 10    | 1010 | #55FF55       | #4EFF4E       |
| 11    | 1011 | #55FFFF       | #4EFFFF       |
| 12    | 1100 | #FF5555       | #FF4E4E       |
| 13    | 1101 | #FF55FF       | #FF4EFF       |
| 14    | 1110 | #FFFF55       | #FFFF4E       |
| 15    | 1111 | #FFFFFF       | #FFFFFF       |

---

## Appendix B: Character Bit Patterns

CP437 characters used for 1024-color mode:

```
Character 'U' (0x55):
Scanline 0: ██  ██   (11001100)

Character '‼' (0x13):
Scanline 0:  ██  ██  (01100110)

Character '░' (0xB0):
Scanline 0:   █    █ (00100010)
Scanline 1: █    █   (10001000)

Character '▒' (0xB1):
Scanline 0:  █ █ █ █ (01010101)
Scanline 1: █ █ █ █  (10101010)
```

---

## Appendix C: Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-12-28 | Research | Initial comprehensive analysis |

---

*This document is part of the pb_core library and is licensed under BSD-3-Clause.*
